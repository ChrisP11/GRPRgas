Let's define success and some requirements yeah?

for the Beta:
~*base.html with look / feel / func for all pages
*home screen - tee times, schedules, request sub/swap, games, data
*tee time - clickable button on home page to pass to the next page
*tee times - see tee times / 4somes for this coming weekend, ability to change date forward or back
*schedules - default view will be the schedule of the user logged in, but ability to search / see anyone's schedule
sub / swap - 2 buttons, one to request a sub for a date, one to request a swap for a date.  backend twilio code to send on submission with an Are You Sure? checkpoint
Games - page with a list of games that can be played.  fleshing this out will be part of 1.0
Data - page with views of various bits of data:  playing distribution could be one, actual play so far could be another

Future items:
- login page
- flesh out game page
- Admin page
- each player clickable, goes to info page with:
	- cell #
	- email address
	- index / CDGA link?
	- playing stats?  (has played 3x this year...)
	- eventually a foto?
- add in today's date awareness
	- for any calendar drop down, the available dates highlighted in a color?
	- fix hard code of date in the tee sheet link on index.html
	- for schedule page have two tables:  future dates, then below that, past dates played
- on teesheet, if a bad date is chosen, fix that there is no error msg
- add in logging steps along the way



Next steps:
1. stop django practice server
2. create a new server
3. set up homepage


20241120 1053a
- created a GRPR folder in /Python/Apps. This will be the 'home' for this app.
- created a virtual environment in /Users/cprouty/Dropbox/Dev/Python/Apps/GRPR.  Maybe I should one place for my virtual environments?  Like /Users/cprouty/Dropbox/Dev/Python/VirtEnvs?  I can do that later.  I think.  Yeesh. cmd line = 'python3 -m venv .env'
- activated the environment 'source .env/bin/activate'
- installed django in the env 'pip install django'
- upgraded pip 'pip install --upgrade pip'
- install dateutil 'pip install python-dateutil' [see if I need this, troubleshooting a date conversion issue at the moment 20241201]
- checked install status:
(.env) cprouty@Chriss-MacBook-Air GRPR % pip freeze
asgiref==3.8.1
Django==4.2.16
sqlparse==0.5.2
typing_extensions==4.12.2

- created a project 'django-admin startproject portfolio .'
- the 'dot' at the end tells the django admin app to create the project inside the portfolio folder instead of creating another folder called 'portfolio' inside the 'portfolio folder 
- started the server 'python manage.py runserver'
(server is functioning and rudimentary website is available at http://127.0.0.1:8000/)
- create first app 'python manage.py startapp GRPR'
(this creates a bunch of folders/files inside the django folder structure under a GRPR folder)

- Inside /portfolio/settings.py file to the INSTALLED_APPS section added:
'    # my apps
    'GRPR','

- Added following line in urlpatterns in /portfolio/urls.py
'path('GRPR/', include('GRPR.urls')),'

- Created a new file called urls.py but in the GRPR folder.  Then added the following code into it:
'from django.urls import path
from GRPR import views

urlpatterns = [
    path('', views.home_page),
]'

- to /portfoli/urls.py I updated the import at the beginning to also have 'include' bc I noticed VScode was throwing an error ( via underlining)
'from django.urls import include, path'

- to /GRPR/views.py add:
'def home_page(request):
    pass'

- added file path info to settings.py to the Templates section
             BASE_DIR /  'GRPR/templates',

- created a folder /GRPR/templates/GRPR to do the double folder structure thing.  I did this prompted by my earlier notes, but those may be somewhat incomplete so I can copied the format of the dev project

- created the index.html file in /GRPR/templates/GRPR.  Copied the code from what I built in the dev project

ISSUE:  was getting a 404 error.  Did some troubleshooting with ChatGPT (what we are here for) 

Changed two things:
1. in /portfolio/urls.py I added:
'path('', include('GRPR.urls')),'
this allowed(?) Django to know where to go (via the '') for the 8000 port request.

2. changed the /GRPR/views.py to the following:

'from django.shortcuts import render
from django.http import HttpResponse

# Create your views here.
def home_page(request):
    return HttpResponse("Hello, world! This is the GRPR app.")
    # pass
    # return render(request, 'GRPR/index.html')'

added in the http import so the httpresponse thing would work

Ah, ok.  Then when commented out the HttpResponse and uncommented the return render, I get my home page.

So....  the issue was I did not have '' available?  in the /portfolio/urls.py file.  Yes.  Confirmed with some commenting.  Interesting.

opened up current GRPR mysql DB:
mysql -u root  -p
pword is H1ghSm1th&nvil


Create base.html
- created base.html file, copied over content from dev work
- created indexB.html to use as trial and error to get look / feel right.  copied over from detail.html in dev work

ran into problems bc those copied files had namespace stuff + variables in them.  Cleaned that up so the base works (gets me the menu bar at the top), but now I need to replace the 'Test test test' text with the buttons and stuff from index.html.  That will take a bit I suspect.

20241121 102p
K.  F'd around with the base.html config trying to get it to work and realized I am putting the cart before the horse.  base is about DRY and at this point, I need to be worried about functionality.  So, pivoted and got the top of page nav bar working with the vertical big buttons of the home page.  Even looks halfway ok in mobile mode.  I understand maybe 10% of the html etc, but good enough for now.  Can come back to this later.

next up:  home screen - clickable buttons that pass to the next page

changes so far
1. added to /GRPR/urls.py urlpatterns section:
'path('tee_times', views.tee_times),'
2. added to /GRPR/views.py:
'def tee_times(request):
    return render(request, 'GRPR/teetimes.html')'
3. added to index.html (for the home just to verify func):
'<a class="nav-link" href="tee_times">Home</a>'
4.  specific to what I was trying to do, added this to index.com:
'<a href="tee_times" class="btn btn-primary" role="button">Tee Sheet</a>'

I am somewhat bothered that the button is 'tee sheet' but the names are 'tee times'.

Ok.  Changed everything to tee sheet

1. added to /GRPR/urls.py urlpatterns section:
'path('tee_sheet', views.tee_sheet),'
2. added to /GRPR/views.py:
'def tee_sheet(request):
    return render(request, 'GRPR/teesheet.html')'
3. added to index.html (for the home just to verify func):
'<a class="nav-link" href="tee_sheet">Home</a>'
4.  specific to what I was trying to do, added this to index.com:
'<a href="tee_sheet" class="btn btn-primary" role="button">Tee Sheet</a>'

ok.  altering my execution for this step as well.  Instead of all buttons being clickable, just doing tee sheet button.  Then gonna build out the tee sheet page.

next step:
tee times - see tee times / 4somes for this coming weekend, 

a lot to this.
1. set up SQLite DB
2. create tables for the DB

added to /GRPR/models.py:
class Courses(models.Model):
    crewID = models.IntegerField()
    courseName = models.CharField(max_length=256)
    courseTimeSlot = models.CharField(max_length=256)

    class Meta:
        db_table = "Courses"

class Crews(models.Model):
    crewName = models.CharField(max_length=256)
    crewCaptain = models.IntegerField()
    email = models.CharField(max_length=256)
    mobile = models.CharField(max_length=256)

    class Meta:
        db_table = "Crews"

ran 'python manage.py makemigrations'
ran 'python manage.py migrate'
opened the SQLite Viewer in VScode - find db.sqlite3 file in /portfolio, right click, choose 'Open Database'

3. fill tables with data from last year
from GRPR.models import Courses  
p1 = Courses(crewID = 1, courseName = "Maple Meadows", courseTimeSlot = "8:00")
p1.save()

p1 = Courses(crewID = 1, courseName = "The Preserve", courseTimeSlot = "08:50")
p1.save()

p1 = Courses(crewID = 1, courseName = "The Preserve", courseTimeSlot = "9:00")
p1.save()

So annoying.  Was hoping to be able to use ChatGPT to write all the data xfer code - save time etc.  But down a rabbit hole and as you can see above, I had to insert the data by hand.  Another thing to come back to. (20241125 - I eventually solved the dataloader thing - better solution I think)

p1 = Crews(crewName = "Coogan GAS", crewCaptain = 6, email = "Christopher_Coogan@rush.edu", mobile = "17083342800")
p1.save()

4. pull data sample on to page
- added in views.py:
'from GRPR.models import Courses'
	to the tee sheet func
'courses = Courses.objects.all()
    return render(request, 'GRPR/teesheet.html', {'courses':courses})'

- added in teesheet.html:
'        {% for course in courses %}
        <h1>{{course.courseName}}  {{course.courseTimeSlot}}</h1>
        {% endfor %}'

Now a little detour.  I want more data to play with so going to go off and create + fill in the other tables.

Created TeeTimes and Players tables
F.  Running into issues importing data into Players bc the SplitPartner field will not accept Nulls.



5. create format for the page
- maybe the three card format from the dev project works/. Or something like that?  With Date at top



p1 = Crews(crewName = "Coogan GAS", crewCaptain = 6, email = "Christopher_Coogan@rush.edu", mobile = "17083342800")
p1.save()


Select concat("p = Players(CrewID = ", CrewID, " ,FirstName = '", FirstName, "',LastName = '", LastName, "' ,Email = '", Email, "' ,Mobile = '", Mobile, "',SplitPartner = ", SplitPartner, ") p.save()")
from Players
Where SplitPartner is not null;

Select concat("p = Players(CrewID = ", CrewID, " ,FirstName = '", FirstName, "',LastName = '", LastName, "' ,Email = '", Email, "' ,Mobile = '", Mobile, "')") p.save()")
from Players
Where SplitPartner is null;

Select concat("p = Players(CrewID = ", CrewID, " ,FirstName = '", FirstName, "',LastName = '", LastName, "' ,Email = '", Email, "' ,Mobile = '", Mobile, "') p.save()")
from Players
Where SplitPartner is null;

from GRPR.models import Players

20241125 1228p
Ok.  Inserting data by hand as I have been doing is getting all spaghetti and non-repeatable.  Not very programmed so to speak.  Especially given I will need to be able to deploy future environments in a repeatable fashion - including data loading.  So, at the risk of gilding the lily, going back to try to get the dataloader file solution working.

The blocker I ran into earlier was ...  well, I will let ChatGPT tell you:

'the script is running outside the Django framework, and the Django environment isn't initialized. This is common when running standalone scripts that interact with Django models.'

Yeesh.  Ok.  Banged that out with a bunch of dumb errors on my part.  Let's see if I can recreate the stuff that worked.

1.  Moved the dataLoader.py file to the /Users/cprouty/Dropbox/Dev/Python/Apps/GRPR folder
2.  Added the following to the script
'import os
import django

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'portfolio.settings')# Replace 'myproject' with your project name
django.setup()'

3. The key bit was 'portfolio.settings' v 'GRPR.settings' which is what ChatGPT thought - based on a different assumption on django folder structure?

Once that was done, I think that made the 'python dataLoader.py' command work from the folder listed above.

Ok.  Gotta take the boys out.  The DogFather's work is never done.

When I get back, lets delete all the tables and then rebuild + repopulate programmatically.

use the python db shell to delete the tables:
1. python manage.py dbshell
2. delete tables:
DROP TABLE IF EXISTS Courses;
DROP TABLE IF EXISTS Players;

huh.  was able to delete the tables but then running the migration scripts did not bring them back even though they are in models.py

ran 'python manage.py makemigrations'
ran 'python manage.py migrate'

Oh F.  The process ChatGPT had me do (all its fault - manual deletion of the tables) occurred outside of django's knowledge and now it wants me to get into other weeds.  Fucker.

1. Delete Migration Files:
Go to the migrations folder of the app (e.g., myapp/migrations/).
Delete all files except __init__.py.

2.Delete the django_migrations Entries: Open the SQLite shell:
2a. python manage.py dbshell
2b. Run the following SQL to delete the migration history for the app:
DELETE FROM django_migrations WHERE app = 'GRPR';
Replace app_name with your app's name.

3. Recreate Migrations: Generate new migrations:
python manage.py makemigrations
python manage.py migrate

And....  that did not work either.  Grrr.  bc I only deleted some tables not all tables.  F.

# Clear DB data process
1. python manage.py dbshell
2. delete tables:
DROP TABLE IF EXISTS Courses;
DROP TABLE IF EXISTS Players;
DROP TABLE IF EXISTS Crews;
DROP TABLE IF EXISTS TeeTimes;
DROP TABLE IF EXISTS TeeTimesInd;
DELETE FROM django_migrations WHERE app = 'GRPR';
3. Delete Migration Files:
Go to the migrations folder of the app (e.g., myapp/migrations/).
Delete all files except __init__.py.
4. Recreate Migrations: Generate new migrations:
python manage.py makemigrations
python manage.py migrate
5. Load data 
python dataLoader.py

Ok.  That worked.  Total PITA.  Gotta be a better way.  But but, let's get back to main path.  Let's populate the tables proper like.

Players data in right format, need to run results through excel to get in  proper order.  Annoying
Select ID, concat("(", CrewID, ", '", FirstName, "', '", LastName, "', '", Email, "', '", Mobile, "', ", SplitPartner, "),") from Players
Where SplitPartner is not NULL;

Select ID, concat("(", CrewID, ", '", FirstName, "', '", LastName, "', '", Email, "', '", Mobile, "', None),") from Players
Where SplitPartner is NULL;

TeeTimes data is correct format
Select concat("(", CrewID,",'", gDate,"',", CourseID,",", P1ID,",", P2ID,",", P3ID,",", P4ID, "),") from TeeTimes;

Ok.  That worked after some stop-go, but ChatGPT was pretty good at shortening up the blocker resolution.

Now....  drop all the tables and recreate them and stuff (# Clear DB data process)

Well shit.  That all worked.  wowzer.

Next?

Probably the cards / tee times thing?  Let me go back to my list.

*
tee times - see tee times / 4somes for this coming weekend, ability to change date forward or back

5. create format for the page
- maybe the three card format from the dev project works/. Or something like that?  With Date at top
*

Copied from previously in bt the *'s

next step specific:
Get Date and the three foursomes on the Tee Sheet page

Hmmm.  two issues:
1. How to pull a wider set of data to the tee sheet page (see below for what I have available now).
2. What is the query I will need/want?

second bit first.
- will need 'this weekends' date (will hard code this obv)
- the course, time, plus 4 somes for this date


4. pull data sample on to page
- added in views.py:
'from GRPR.models import Courses'
	to the tee sheet func
'courses = Courses.objects.all()
    return render(request, 'GRPR/teesheet.html', {'courses':courses})'

- added in teesheet.html:
'        {% for course in courses %}
        <h1>{{course.courseName}}  {{course.courseTimeSlot}}</h1>
        {% endfor %}'


Oh boy.  Off into the wilderness (smh).  Now I am finally getting around to changing the TeeTimes table to only have one player per row (but 4 rows per 4some).  This will allow joining of the TeeTimes table with the Players table.  I think there are other ways to do this, but....  whatever.

Create Table TeeTimesInd(
	TeetimeID INT PRIMARY KEY AUTO_INCREMENT
	, CrewID INT
	, gDate DATE
	, CourseID INT
	, PID INT
	);

Insert into TeeTimesInd (CrewID, gDate, CourseID, PID)
Select CrewID, gDate, CourseID, P4ID from TeeTimes;

Select T.gDate
,C.CourseName
,C.CourseTimeSlot
,P.FirstName
,P.LastName 
from TeeTimesInd T 
left outer join Players P
on T. PID = P.ID
left outer join Courses C
on T. CourseID = C.CourseID
Where T.gDate = '2024-07-13';

Ok.  Next step - make a new table in the django enviro and load up from MySQL.

Added this to Models.py:
class TeeTimesInd(models.Model):
    CrewID = models.IntegerField()
    gDate = models.DateField()
    CourseID = models.IntegerField()
    PID = models.IntegerField()

    class Meta:
        db_table = "TeeTimesInd"

Select concat("(", CrewID,",'", gDate,"',", CourseID,",", PID, "),") from TeeTimesInd;

Alrighty.  I am good?  Now I just need to do the kill tables / make tables thing?

Ok.  All good.  Now where was I?

Oh yeah.

Next Step:  
pull date + the three 4somes on to the tee time page
- How do I do a cross join statement in django?

Let's see if I can remember everything:
1.  Added this to views.py:
from GRPR.models import TeeTimesInd
from django.db import connection

AND 


def teesheet_view(request):
    date_filter = '2024-07-13'
    with connection.cursor() as cursor:
        cursor.execute('''
            SELECT T.gDate, C.CourseName, C.CourseTimeSlot, P.FirstName, P.LastName
            FROM TeeTimesInd T
            LEFT OUTER JOIN Players P ON T.PID = P.ID
            LEFT OUTER JOIN Courses C ON T.CourseID = C.id
            WHERE T.gDate = %s;
        ''', [date_filter])
        rows = cursor.fetchall()

    formatted_data = [
        {
            'gDate': row[0],
            'courseName': row[1],
            'courseTimeSlot': row[2],
            'firstName': row[3],
            'lastName': row[4],
        }
        for row in rows
    ]

    return render(request, 'GRPR/teesheet.html', {'teesheet_data': formatted_data})

2. added this to GRPR/urls.py:
path('tee_sheet', views.teesheet_view, name='teesheet'),

3. Changed teesheet.html to this:
        {% for item in teesheet_data %}
            <h1>{{ item.gDate }}</h1>
            <h1>{{ item.courseName }}</h1>
            <h1>{{ item.courseTimeSlot }}</h1>
            <h1>{{ item.firstName }}</h1>
            <h1>{{ item.lastName }}</h1>
        {% endfor %}

Actually, just changed it to the table format recommended by CGPT:
<table>
    <thead>
        <tr>
            <th>Date</th>
            <th>Course Name</th>
            <th>Time Slot</th>
            <th>First Name</th>
            <th>Last Name</th>
        </tr>
    </thead>
    <tbody>
        {% for item in teesheet_data %}
        <tr>
            <td>{{ item.gDate }}</td>
            <td>{{ item.courseName }}</td>
            <td>{{ item.courseTimeSlot }}</td>
            <td>{{ item.firstName }}</td>
            <td>{{ item.lastName }}</td>
        </tr>
        {% endfor %}
    </tbody>
</table>

Next:  Just pull the date once, the course/time once per 4 some, then each 4some

after that, card them up and start on prettiness.

20241126 1007a
path to get query data displayed in django:
- /GRPR/urls.py - urlpatterns
ex:  path('tee_sheet', views.teesheet_view, name='teesheet')
*'tee_sheet' is the html path(?) - http://127.0.0.1:8000/tee_sheet
* views.teesheet_view is the /views.py path to follow (def teesheet_view(request):)
* name='teesheet' ... no idea?
- views.py - defined functions
- teesheet.html - html code plus variable pulls

I want to use the same database query but get the data a bit differently.
I want the date just once
I want to be able to iterate through the courses returned, getting the course once, but the firstName and Lastname

date
use date to get a list of courses
iterate through course list and use date + course to get the 4 players


SELECT T.gDate, C.CourseName, C.CourseTimeSlot
FROM TeeTimesInd T
LEFT OUTER JOIN Courses C ON T.CourseID = C.id
WHERE T.gDate =


1. created forms.py:
from django import forms

class DateForm(forms.Form):
    gDate = forms.DateField(
        widget=forms.DateInput(attrs={
            'type': 'date',  # HTML5 date picker
            'class': 'form-control',
        }),
        label='Select a date',
    )

2. to views.py:
from GRPR.forms import DateForm

def teesheet_view(request):
    form = DateForm(request.GET or None)  # Use GET to retrieve date from query parameters
    teesheet_data = []

    if form.is_valid():
        gDate = form.cleaned_data['gDate']
        # Filter TeeTimesInd based on the selected date
        teesheet_queryset = TeeTimesInd.objects.filter(gDate=gDate).select_related('PID', 'CourseID')

        # Format data for the template
        teesheet_data = [
            {
                'gDate': t.gDate,
                'courseName': t.CourseID.courseName,
                'courseTimeSlot': t.CourseID.courseTimeSlot,
                'firstName': t.PID.FirstName,
                'lastName': t.PID.LastName,
            }
            for t in teesheet_queryset
        ]

    return render(request, 'GRPR/teesheet.html', {'form': form, 'teesheet_data': teesheet_data})

3.  Updated Models.py to be able to use the query format of Django ORM:
class TeeTimesInd(models.Model):
    CrewID = models.IntegerField()
    gDate = models.DateField()
    PID = models.ForeignKey('Players', on_delete=models.CASCADE)  # Links to Players table
    CourseID = models.ForeignKey('Courses', on_delete=models.CASCADE)  # Links to Courses table

    class Meta:
        db_table = "TeeTimesInd"
       

Instead of the data being displayed in a table, I want to display it in a card format.  For each gDate there will be a card per course and courseTimeSlot returned.  On that card will be the date, the course, the courseTimeSlot, and every associated FirstName and LastName returned by the query.


F.  That was a rabbit hole with lots of twists and turns and I was reduced to c/p'ing whatever CGPT told me.  Not my favorite.  Ended up deploying a brand new teesheet.html and a new func in views.py.  BUT....  got the result I wanted sans better formatting.

I will take the boys for a walk and come back and see if I can reverse engineer.

745p
Ok.  Came home, F'd aroudn with some stuff (related to grpr), watched Arsenal, went to yoga, cooked dinner, and I'm back.  trying to get the date pulled out all on its own.

Well shit, CGPT did that pretty well.

Two changes:
1. New func in views.py
def teesheet_view(request):
    # Check if the form was submitted
    if request.method == "GET" and "gDate" in request.GET:
        gDate = request.GET["gDate"]

        # Handle the case where the date is not provided
        if not gDate:
            return HttpResponseBadRequest("Date is required.")

        # Query the database
        queryset = TeeTimesInd.objects.filter(gDate=gDate).select_related('PID', 'CourseID')

        # Construct the cards dictionary
        cards = {}
        for teetime in queryset:
            courseName = teetime.CourseID.courseName
            courseTimeSlot = teetime.CourseID.courseTimeSlot
            key = (courseName, courseTimeSlot)
            
            if key not in cards:
                cards[key] = {
                    "courseName": courseName,
                    "courseTimeSlot": courseTimeSlot,
                    "gDate": gDate,
                    "players": []
                }
            
            player = teetime.PID
            cards[key]["players"].append({
                "firstName": player.FirstName,
                "lastName": player.astName
            })

        # Pass data to the template
        context = {
            "cards": cards,
            "gDate": gDate  # Add the chosen date to the context
        }
        return render(request, "GRPR/teesheet.html", context)
    else:
        return HttpResponseBadRequest("Invalid request.")

2. added this to the teetimes.html file:
    <!-- Display the chosen date -->
    {% if gDate %}
        <h2>Date: {{ gDate }}</h2>
    {% else %}
        <h2>Please select a date.</h2>
    {% endif %}

    <!-- Display the cards -->
    {% for card in cards.values %}
        <div class="card">
            <h3>{{ card.courseName }} ({{ card.courseTimeSlot }})</h3>
            <p>Date: {{ card.gDate }}</p>
            <ul>
                {% for player in card.players %}
                    <li>{{ player.firstName }} {{ player.lastName }}</li>
                {% endfor %}
            </ul>
        </div>
    {% endfor %}

Crazy how big the func in views.py has gotten.

Ooof.  Does not quite work.  To get to the page from the index page, the format will need to be:  http://127.0.0.1:8000/GRPR/tee_sheet?gDate=2024-07-13 (or at least a date in there.  Hmmmm.)

hmmm.  Changing this button on index.html from:
<a href="tee_sheet" class="btn btn-primary" role="button">Tee Sheet</a>

to <a href="tee_sheet?gDate=2024-07-13" class="btn btn-primary" role="button">Tee Sheet</a>

works.  Though it defaults to 7/13/24.  Good enough for now.  Later I can figure out the nearest date thing I do in the Twilio code.

20241127 1117a
ok.  Let's do just a little bit of cleanup and then on to look and feel?

*put nav bar back on teesheet
*make home button work
This was fun.  GPT gave me a couple options, I chose the second, more complex but less fragile one:

If you're using Django's template tags for reverse URL resolution, you can use the {% url %} tag in your template:

<a href="{% url 'home_page' %}" class="btn btn-primary" role="button">Home</a>
For this to work, you would need to name your home_page URL in urls.py:

urlpatterns = [
    path('', views.home_page, name='home_page'),
    path('tee_sheet', views.teesheet_view, name='teesheet_view'),
]
Using {% url %} ensures that your URLs will still work even if you later change the path in urls.py.

Ok.  Next steps are better formatting on teesheet plus some mobile format work?

*get space between the cards
*make the cards more narrow and center them
*same thing for date input form

ha.  Ok.  GPT just did that shit for me.  Yeesh.  This is more or less exactly what I am hoping for out of AI.  And with the agent stuff coming...  I could just tell AI how I want the page to look like, back end func, etc and it would make it for me?  Whoa.  Maybe Renner should do a different career / major.

Along those lines (kind of), I started work on the actual website exactly one week ago.  Let's say an average of 3 hrs per day (may be high) and I have the home page, the tee sheet page, the data etc all set up.  20+ hrs of work?  Most of which I have been using to learn how this all works?  Ok.  Not terrible.

Next step:
schedules - default view will be the schedule of the user logged in, but ability to search / see anyone's schedule

- create schedule.html (dmn...  this is where maybe I should spend some time on a base.html?) in the same format.
- default / hard code to me to start
- show list of dates in order the player is playing, the course and timeslot they are playing at and the other three players in each group
- drop down picker with any player


Ok.  Let's write this as a prompt for GPT:
Working in the same code base we have been working in, I want to create a new webpage called Schedule.
- from index.html, the user will be able to click on the 'Schedule' button to get to the page.
- the schedule.html page will have the same look and feel as the teesheet.html page - including the nav bar at the top
- there will be a form at the top with a drop down of all the players (LastName, FirstName) in the Players table.
- When a player is chosen, a table will be displayed below with the following columns: Player (display FirstName Lastname), Date, Course, Time Slot, other players in the group (in one cell)
- this table should be ordered by date descending

Let me know what changes need to be made to other files (views.py, urls.py, etc) in the code base.

Holy fuck.  That worked perfectly.  other than me screwing up descending v ascending.  jesus good god.

Next Step:  change default color to golf green (008e70)
I did that, but took a bit:
1. Create a CSS file in static/css/styles.css
2.  code for the css file:
.btn {
    background-color: #008e70 !important;
    border-color: #008e70 !important;
    color: white !important;
}

.btn:hover {
    background-color: #006a54 !important; /* Slightly darker shade for hover effect */
    border-color: #006a54 !important;
}

3. include the following right after <head> in each html file:
<link rel="stylesheet" href="{% static 'css/styles.css' %}">

4. update settings.py:
STATIC_URL = '/static/'
STATICFILES_DIRS = [BASE_DIR / "my_app/static"]

5.  Add {% load static %} to the top of the HTML file (right after <html lang="en">)

6. Restart the Django server:
python manage.py runserver

Lost my secondary button being white, which I really liked, bit will circle back on that later


Next Step:
sub / swap - 2 buttons, one to request a sub for a date, one to request a swap for a date.  backend twilio code to send on submission with an Are You Sure? checkpoint

Working in the same code base we have been working in, I want to create a new webpage called SubSwap.
- from index.html, the user will be able to click on the 'Sub / Swap' button to get to the page.  In the future this will be aware of the user's login and only show future schedule for the logged in user.  For now, hard code the user to be 'Chris Prouty'
- the subswap.html page will have the same look and feel as the schedule.html page - including the nav bar at the top
- the page will display an <h1> of 'Schedule for FirstName LastName' of the logged in user (hard coded to Chris Prouty for now) and a table of the schedule listed below in the same format / columns of te schedule.html file
- this table should be ordered by date ascending
- at the end of each row there will be two buttons:  Sub and Swap
- These buttons will be clickable later on
- include customized css / {% load static %} for html

Goodness.  I haven't tested anything, but F....  this works so good!  Only thing that did not work right off the bat was that GPT did not add load static for whatever reason but kind of warned me to, so I added it to the prompt above for future use.

Went and got the secondary button color to be white.  Required a bit of work in the css/styles.css file.  Not gonna replicate it here, but mostly involved adding 'important!' to the secondary buttons to override other parameters - also specific coding on buffers etc.  Basically just c/p'd GPT work.

Next step:
Create the process for actually doing a Sub

Working in the same code base we have been working in, I want to create a new webpage called subrequest.
- the subrequest.html page will have the same look and feel as the subswap.html page - including the nav bar at the top
- from subswap.html, the user will be able to click on the 'Sub' button at the end of each row in the displayed table to get to the subrequest.html page. The following data from that row will need to be passed to the new page: the date, the course, the time slot, the other players.  the user id will also need to be passed.  All of this data should be printed out at the top of the subrequest.html page (just temporary,for debugging)
- ***

- the page will display an <h1> of 'Schedule for FirstName LastName' of the logged in user (hard coded to Chris Prouty for now) and a table of the schedule listed below in the same format / columns of te schedule.html file
- this table should be ordered by date ascending
- at the end of each row there will be two buttons:  Sub and Swap
- These buttons will be clickable later on
- include customized css / {% load static %} for html

OfferDetails = Player is offering his slot on Date, at TimeSlot

Ok, good work today.  Have hit a thinking block, come back and go to *** above, but the key bit is:  
- what data do I have on the SubSwap page already?  
- what of that data (or underlying unique IDs) do I need to pull together to put together the Offer Details?
- put together the OfferDetail, display it on the page
- have a confirm or cancel button
- if confirm, at least at first, it will just produce another page with the Offer Detail and who that will be sent to (everyone not playing on the date in particular).

20241128 1035a
Happy Thanksgiving.

Nice thing about this project is that it draws me in.  This is what I am looking for, how I want to spend my time.  Now if I could replace sitting on the couch, drinking, eating, watching bad shows with doing this work or...  painting....  I would be a happier boy.  poco a poco mutherfucker.

Ok.  Back to the problem.  Looking at the subswap.html code I see where GPT has brought over and hidden the userid info.  I think I need more info, but the question is:  do I bring over the info when I load this page (subswap) or do I pull it when the sub or swap button is hit?  Which is the more efficient / better solution?

What am I trying to do?  When the sub button is hit, The next page generates:
- the Offer Detail (date, course, time, other players in the 4some, offering player)
- a confirm (yes, I want to offer this out to the group) or a cancel (nope, crazy talk, I am playing!)
- when the confirm button is hit, that will get the available players, their mobile, and then kick off the twilio process complete with Offer Detail

The data I need for the Offer Detail to be generated:
- offering player usedID
- date
- timeSlot
- courseID
- the userID of each of the other players in the 4some

Since this data is all pulled (or the adjacent data is pulled) to generate the subswap page, I think it should be pulled (like userID) when the .... wait

The actual data (offering player usedID, date, timeSlot, courseName, other player names) we need is already pulled with that page generation.  We just need to store that data like we already have userid ready for the sub button to be hit.

When that button is hit, the user will go to the next page where the Offer Detail will be displayed

{Offering Player} is offering his tee time on {gDate} at {CourseName} {courseTimeSlot} playing with {the text from the Other Players column} to the first person who wants it.  Click this link to take the tee time.

Do you wish to send out this Sub Request to the group?
There will be two buttons available below that:  Confirm and Cancel

20241130 1023a
Skipped a day but back at it.

Working on prompt for GPT.

I want to create a new page when the Sub button is clicked.
- the new page will be called subrequest.html
- subrequest.html will have the same look and feel as subswap.html, including nav bar and any customized css / {% load static %} requirements.
- on clicking the button, the following data will be passed to the new page (subrequest.html) from data already in that row of the table on the subswap.html page:
	- {{ user_name }} 
	- {{ entry.date }}
	- {{ entry.course }}
	- {{ entry.time_slot }}
	- {{ entry.other_players }}
- the subrequest.html page will then display the following below the nav bar:

	Please confirm you would like to request a sub for {{ entry.date }}.  If you click the Confirm button the following message will be sent to the members of the group who are available to play on {{ entry.date }}:
	
	{{ user_name }} is offering his tee time on {{ entry.date }} at {{ entry.course }} {{ entry.time_slot }} playing with {{ entry.other_players }} to the first person who wants it.  Click this link to take the tee time.

- below this text in the same format as the Sub and Swap buttons on subswap.html will be two buttons:  Confirm (primary style) and Cancel (secondary style)
- These buttons will be clickable later on

bang.  One error due to GPT being inconsistent with how it names views (sometimes just the name of the page, sometimes name_view), but otherwise easy peasy.

Changes made:
1. subswap.html to Pass Data
Modify the Sub button in subswap.html to include the required data in the URL parameters using the href attribute or a form.
<a href="{% url 'subrequest' %}?user_name={{ user_name }}&date={{ entry.date }}&course={{ entry.course }}&time_slot={{ entry.time_slot }}&other_players={{ entry.other_players }}" class="btn btn-primary btn-sm">
    Sub
</a>

2. Update urls.py
Add a new route for the subrequest.html page:
urlpatterns = [
    path('subrequest', views.subrequest_view, name='subrequest_view'),  
    
3. Create a View for subrequest.html
def subrequest_view(request):
    # Get data passed via query parameters
    user_name = request.GET.get('user_name', 'User')
    date = request.GET.get('date', 'Unknown date')
    course = request.GET.get('course', 'Unknown course')
    time_slot = request.GET.get('time_slot', 'Unknown time slot')
    other_players = request.GET.get('other_players', 'No other players')

    # Pass data to the template
    context = {
        'user_name': user_name,
        'date': date,
        'course': course,
        'time_slot': time_slot,
        'other_players': other_players,
    }
    return render(request, 'GRPR/subrequest.html', context)

4. Create subrequest.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub Request</title>
    {% load static %}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>
<body>
    <!-- Nav bar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand">GAS Golf</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item active">
                        <a href="{% url 'home_page' %}" class="nav-link">Home</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Sub Request Content -->
    <div class="container my-4">
        <h1>Sub Request</h1>
        <p>
            Please confirm you would like to request a sub for <strong>{{ date }}</strong>. 
            If you click the <strong>Confirm</strong> button, the following message will be sent to the members of the group who are available to play on <strong>{{ date }}</strong>:
        </p>
        <blockquote class="blockquote">
            {{ user_name }} is offering his tee time on <strong>{{ date }}</strong> at <strong>{{ course }}</strong> 
            <strong>{{ time_slot }}</strong>, playing with <strong>{{ other_players }}</strong>, to the first person who wants it. 
            <br>
            Click this link to take the tee time.
        </blockquote>
        <div class="mt-4">
            <a href="#" class="btn btn-primary">Confirm</a>
            <a href="{% url 'subswap' %}" class="btn btn-secondary-custom">Cancel</a>
        </div>
    </div>

</body>
</html>

I do want to clean up the look and feel a bit for the new page.
Goodness.  GPT even anticipated the correct path to follow if someone clicks the cancel button - back to the subswap page.

Next step: Generate the list of Mobile numbers the sub request will be sent to.

What do we need?
1. Get the list of players, mobile from the Players table who are not playing on the sub date.
2. Take the offer detail from the subrequest page and 'send' it to each mobile number plus 312-296-1817

prompt:
I want to create a new page when the Confirm button on subrequest.html is clicked.
- the new page will be called subrequestsent.html
- subrequestsent.html will have the same look and feel as subrequest.html, including nav bar and any customized css / {% load static %} requirements.
- on clicking the button, the following data will be passed to the new page (subrequestsent.html) from data on the subrequest.html page:
	- {{ entry.date }}
	- the text of the sub offer (this has been updated since we made the subrequest.html page - please use this):  {{ user_name }} is offering his tee time on <strong>{{ date }}</strong> at <strong>{{ course }}</strong> <strong>{{ time_slot }}</strong> to play with <strong>{{ other_players }}</strong> to the first person who wants it. 
- Using the {{ entry.date }} the page will query the TeeTimesInd table to find the full list of Players playing on that date.  It will then subtract this list of players from the list of all players in the group.  It will then subtract Player with Unique ID 25 (Course Credit).  The remaining group will be the Available Players list.
-the subrequestsent.html page will then print the sub offer below the nav bar and then a table below the sub offer.  The table will be of the Available Players below the nav bar with the following columns: FirstName, LastName, Mobile

Again, worked very well with some minor errors I had to correct.  But....  just minutes to get this done.

1. Update the Confirm Button on subrequest.html
Modify the Confirm button to pass the necessary data ({{ entry.date }} and the sub offer) to the new page:
<a href="{% url 'subrequestsent' %}?date={{ date }}&sub_offer={{ user_name }} is offering his tee time on {{ date }} at {{ course }} {{ time_slot }} to play with {{ other_players }} to the first person who wants it." class="btn btn-primary">
    Confirm
</a>

2. Update urls.py
Add a new route for the subrequestsent.html page:
urlpatterns = [
    path('subrequestsent', views.subrequestsent_view, name='subrequestsent'),  # New URL
]

3. Create a View for subrequestsent.html
Add the following logic in views.py:

from django.shortcuts import render
from GRPR.models import TeeTimesInd, Players
from datetime import datetime

def subrequestsent_view(request):
    # Get data passed via query parameters
    date_raw = request.GET.get('date', 'Unknown date')
    sub_offer = request.GET.get('sub_offer', '')

    try:
        # Convert the raw date to YYYY-MM-DD format
        date = datetime.strptime(date_raw, "%B %d, %Y").strftime("%Y-%m-%d")
    except ValueError:
        # Handle invalid date formats gracefully
        return render(request, 'GRPR/error.html', {'error_message': 'Invalid date format.'})

    # Get players already playing on the date
    playing_players = TeeTimesInd.objects.filter(gDate=date).values_list('PID_id', flat=True)

    # Get all players and subtract playing players and Course Credit (ID 25)
    available_players = Players.objects.exclude(id__in=list(playing_players) + [25])

    # Pass data to the template
    context = {
        'date': date,
        'sub_offer': sub_offer,
        'available_players': available_players,
    }
    return render(request, 'GRPR/subrequestsent.html', context)

4. Create subrequestsent.html
Copy the structure from subrequest.html and adjust the content to display the sub offer and the table of available players:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub Request Sent</title>
    {% load static %}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>
<body>
    <!-- Nav bar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand">GAS Golf</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item active">
                        <a href="{% url 'home_page' %}" class="nav-link">Home</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Sub Request Sent Content -->
    <div class="container my-4">
        <h1>Sub Request Sent</h1>
        <p>
            {{ sub_offer }}
        </p>
        <h2>Available Players</h2>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>First Name</th>
                    <th>Last Name</th>
                    <th>Mobile</th>
                </tr>
            </thead>
            <tbody>
                {% for player in available_players %}
                    <tr>
                        <td>{{ player.FirstName }}</td>
                        <td>{{ player.LastName }}</td>
                        <td>{{ player.Mobile }}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</body>
</html>

Next:  Get the Swap button working.  This will be harder.

prompt:
I want to create a new page when the Swap button is clicked on the subswap.html page
- the new page will be called swaprequest.html
- it will be the exact same as subrequest.html except:
	- the word 'Sub' should be replaced by the word 'Swap' everywhere on the page.
	- Alter the verbiage used on the subrequest.html page ( {{ user_name }} is offering his tee time on {{ date }} at  {{ course }} {{ time_slot }} to play with {{ other_players }} to the first person who wants it.) to:  {{ user_name }} would like to swipe his tee time on {{ date }} at  {{ course }} {{ time_slot }} (playing with {{ other_players }}) with one of your tee times.

Ok.  That worked though I noticed GPT swapped in a different sort of button logic (<button> v <a>) for the Swap button on SubSwap.html.  After some discussions and explanations, GPT recommended the prior format, the <a>, to use.

(note:  I am NOT going to c/p all the work G [yeah, going with just G for ChatGPT moving forward] did anymore.  Worst case scenario I can just look up the history.  Hopefully I do not regret this)

Next step:  build out the swaprequestsent.html page.

prompt:
I want to create a new page when the Confirm button on swaprequest.html is clicked.
- the new page will be called swaprequestsent.html
- swaprequestsent.html will be the same as subrequestsent.html except:
	- the text of the message at the top will be the same as the message previosuly generated on the swaprequest.html page where the confirm button is clicked.
	- the table will have the same columns, but there will be one additional column:  Available Swap Dates
		- Just as with the generation of the subrequestsent.html table, only players who are not playing on the date requested are in the table
		- Course Credit (unique ID 25 in Players table) is not included
		- the Available Swap Dates data for each row will be generated by comparing the playing dates for the Swap Request Player with the playing dates for the Available Player.  The logic will include the dates in the future where the Available Player is playing and the Swap Request Player is not playing.  Thus the Available Player can offer to swap his future date for the date the Swap Request Player is offering
		
(I also included the code for subrequestsent.html since I fear G is starting to forget what we have done so far).

Ok.  I ran into a blocker!  99% sure it is bc G is screwing up passing the date around in the right format.  But, since I have run out of free G time (at 4.0 anyway) I will come back tomorrow.  Stopping at 612p btw.

20241201 207p
Ok.  I'm back.  Have that eeror on the swaprequestsent.html page.  May have to do actual troubleshooting

date_str May 4, 2024
swap_offer Chris Prouty would like to swap his tee time on May 4, 2024 at The Preserve 9:00 (playing with John Sullivan, John Mcilwain, Keith Huizinga) with one of your tee times.
date May 4, 2024
course None
time_slot None
user_name None
other_players None

date_str May 18, 2024
swap_offer Chris Prouty would like to swap his tee time on May 18, 2024 at The Preserve 8:50 (playing with Brad Hunter, Chris Lynn, Chris Marzec) with one of your tee times.
date May 18, 2024
course None
time_slot None
user_name None
other_players None

date_str May 25, 2024
swap_offer Chris Prouty would like to swap his tee time on May 25, 2024 at The Preserve 9:00 (playing with Tom Canepa, Ed Sloan, Mike DeHaan) with one of your tee times.
date May 25, 2024
course None
time_slot None
user_name None
other_players None

Ok.  The code is not getting any of the variables after date and swap offer

course, time_slot, user_name, and other_players

ok.  I'm in a spiral.  The good news is that it is only the swaprequestsent.html page (and associated components) that is not working.  Spiral-wise, I am chasing error messages etc.  But these are symptoms.  The disease is related to querying the DB with the gDate.  That is not going well at all.

In theory, the swap work should mimic the sub work, but be more complicated bc the sub work just requires a list of available players (guys not playing the gDate in question) and their mobile numbers.  The swap group is the same exact list PLUS a list of future dates where they are playing and the offering player is not.

So, back to simple steps.  What can be re-used from the sub logic chain.

on the subswap.html page, the buttons in the table row pass specific data (only showing one row from the source view in the developer tab thing in Chrome):
<a href="/GRPR/subrequest?user_name=Chris Prouty&date=May 4, 2024&course=The Preserve&time_slot=9:00&other_players=John Sullivan, John Mcilwain, Keith Huizinga" class="btn btn-primary btn-sm">Sub</a>
<a href="/GRPR/swaprequest?date=May 4, 2024&course=The Preserve&time_slot=9:00&other_players=John%20Sullivan%2C%20John%20Mcilwain%2C%20Keith%20Huizinga&user_name=Chris%20Prouty" class="btn btn-sm btn-secondary-custom">Swap</a>

sub
user_name=Chris Prouty&
date=May 4, 2024&
course=The Preserve&
time_slot=9:00&
other_players=John Sullivan, John Mcilwain, Keith Huizinga" 

user_name=Chris%20Prouty
date=May 4, 2024&
course=The Preserve&
time_slot=9:00&
other_players=John%20Sullivan%2C%20John%20Mcilwain%2C%20Keith%20Huizinga&

almost the same....  not enough of a diff to be an issue yeah?  Actual code:

<a href="{% url 'subrequest_view' %}?user_name={{ user_name }}&date={{ entry.date }}&course={{ entry.course }}&time_slot={{ entry.time_slot }}&other_players={{ entry.other_players }}" class="btn btn-primary btn-sm">Sub</a>

<a href="{% url 'swaprequest_view' %}?date={{ entry.date }}&course={{ entry.course }}&time_slot={{ entry.time_slot }}&other_players={{ entry.other_players|urlencode }}&user_name={{ user_name|urlencode }}" class="btn btn-sm btn-secondary-custom">Swap</a>

Interesting, a bit of the 'urlencode' for the Swap button (which explains the slight diff in text above).  Again, do not think this is a huge deal, but this is where maybe the date needs some love?  Eventually.

Confirm button on swaprequest.html
<a href="{% url 'swaprequestsent_view' %}?
date={{ date }}&
course={{ course }}&
time_slot={{ time_slot }}&
user_name={{ user_name }}&
other_players={{ other_players }}" 
class="btn btn-primary">Confirm</a>

Confirm button on subrequest.html
<a href="{% url 'subrequestsent_view' %}?
date={{ date }}&
sub_offer={{ user_name }} is offering his tee time on 
{{ date }} at 
{{ course }} 
{{ time_slot }} to play with 
{{ other_players }} to the first person who wants it." class="btn btn-primary">Confirm</a>
            
Wow.  No idea if I have really fixed it, but walked through the code line by line and noticed there was a slight difference in the date conversion between the sub and swap routines.

For Sub it was:
gDate = datetime.strptime(date_raw, "%B %d, %Y").strftime("%Y-%m-%d")

For Swap it was:
gDate = datetime.strptime(date_raw, "%b. %d, %Y")

Notice the 'b' is capped / not capped, but more importantly, there is a period in one and not the other.  According to G, this was NOT a typo but reflects different conversion strategies from the raw data to the format it was expecting me to need.

Which, what a PITA, but also 'hey that is coding'.  What is more annoying though is that I (we) are getting the date (somewhere) in the original, proper format, and then playing games to get it back to that format later.

Let's verify it actually works.

Ran into an issue with 7/27/24 does not work.  I thought it was bc the date is getting f'd up.  That may be the case, but may not be.  So I have traced where the date comes from and when it gets transmorgified.  It is complicated of course.

index.html - when you click the sub/swap button, this calls the subswap_view func in views.py
views.py subswap_view func returns a bunch of data in a context dictionary (I think it is a dict) - user_name, UserID, and schedule_data.  In schedule_data there is the gDate in this format:  'date': datetime.date(2024, 5, 4)
subswap.html - takes this data in the context dict and paints the page with a table amongst other things.  In that table, this date format becomes Month DD, YYYY.
The Swap button on subswap.html then sends across this data through the swaprequest_view:  <a date={{ entry.date }}&
course={{ entry.course }}&
time_slot={{ entry.time_slot }}&
other_players={{ entry.other_players|urlencode }}&
user_name={{ user_name|urlencode }}

then that date goes via the swaprequest_view.  That view basically keeps the data sent by the prior button ('Swap' on subswap) the same, the swaprequest.html page uses it to display the swap offer, date is still in Month DD, YYYY

The Confirm button on swaprequest.html sends this data via the swaprequestsent_view:
date={{ date }}&
course={{ course }}&
time_slot={{ time_slot }}&
user_name={{ user_name }}&
other_players={{ other_players }} 

This is where it goes wrong.

date_normalized = "July 27, 2024"
gDate = datetime.strptime(date_normalized, "%B %d, %Y").strftime("%Y-%m-%d")
date_normalized = "May 4, 2024"
print(gDate)

datetime.strptime(date_normalized, "%b %d, %Y").strftime("%Y-%m-%d")

installed dateutil at G (but just 3.5G?) suggestion.


Ok.  Victory is mine and it is sweet.  The issue was that django (in the background) converts YYYY-MM-DD dates into Month DD, YYYY format and we need the YYYY-MM-DD format for querying the DB by gDate in a couple places.  G's suggestion was a fairly complex date conversion thingy which...  did not handle the django converted dates well.  Specifically, django was giving me July for July and Aug. for August.  The datetime conversion string G gave me bombed on at least one of these.  So instead of the datetime hoop jumping which did not work well, the lesser G told me to use gDate = parser.parse(date_raw).strftime("%Y-%m-%d") which both normalizes the data and and converts it to YYYY-MM-DD format.  voila.

Ok.  Off to do some cleanup.  I have left print statements everywhere.....

Ok.  Done with cleanup.

Not sure on next.

-add twilio to the sub and swap requests?
- trial co-pilot?

20241202 135p
Busy day already.  Lost Moto in the woods, then got on my list o shit to do on Monday.  Finally back to this.  But only for a few minutes.  Have one more Monday thing to do.

But let's review our list
-add twilio to the sub and swap requests?
-trial co-pilot?
-eliminate players without available dates from swap list
figure out better error handling / error.html
- automate some testing?  look at test frameworks
- order available dates by asc order
- verify available dates are post offer date
- get initial data page going with chart of player played with dates plus chart of which courses played and when (replicate google sheets in essence)

hmm..  only have 5 minutes at most.  let's look at co-pilot real quick.  $10/mo?  Probably sold after the free 30 day trial.

I reallly liked how the G worked (is Copilot going to become C?) but got worried that it was losing track of my code as it grew larger.

Maybe let's get copilot working and then do these 3 relatively minor tasks to see how it works?  With maybe a tutorial on C first?
- order available dates by asc order
- verify available dates are post offer date
- eliminate players without available dates from swap list

Yeesh.  C is already pissing me off.  Good thing I started small....  anyway, suggestions on improving prompting from the C itself:

Context: Provide a brief description of the existing functionality and its purpose.
Specific Requirements: Clearly state what changes or additions you need without altering the existing functionality.
Highlight Key Parts: Point out any critical parts of the code that must remain unchanged.
Examples: If possible, provide examples of expected input and output to clarify the desired behavior.


Goodness.  Ok.  got the ascending date ordering thing going, but, uh, was a total pain and I had to go into dropbox and undelete a fucking file.  Shoot me.  C and I are not friends yet.

Back to my list:
* order available dates by asc order
- verify available dates are post offer date
- eliminate players without available dates from swap list

Deeper list just to have it available
-add twilio to the sub and swap requests?
-trial co-pilot?
- figure out better error handling / error.html
- automate some testing?  look at test frameworks
- get initial data page going with chart of player played with dates plus chart of which courses played and when (replicate google sheets in essence)

Let's do this one:
- eliminate players without available dates from swap list

am I scared to even type the prompt?  Yes I am.  yes.

Context: Current functionality for the Swap function allows a player (via the Sub / Swap button on Index.html) to go to the subswap.html page (which is currently hard coded to only show Chris Prouty tee times but will in the future use the users login to show the logged in user their tee times) and choose a tee time they would like to offer up as a tee time to be swapped for a future tee time date with another user.  When the user chooses the 'Swap' button in the row of the table displayed on subswap.html, this will take the user to the swaprequest.html page.  That page displays the 'swap offer' details (generated via data provided in the 'Swap' button on subswap.html and run through the swaprequest_view function in views.py).  This page allows the user to confirm the details of the tee time they are offering to other players to swap with.  If the user hits the 'Confirm' button on the swaprequest.html page, that will take them to the swaprequestsent.html page.  That page will display (with data acquired via the swaprequestsent_view function in views.py and data associated with the Confirm button on swaprequest.html page) all of the players (first name, last name, mobile number) in the group who are not currently playing on the date the user would like to swap out with a list of future dates each player has that the player offering the swap is not playing on.  IE, dates the swap offering player could possibly play on.
Specific Requirements: The code currently allows available players to be displayed in this table on subrequestsent.html who do not have future dates available where the offering player can play.  IE, the Available Dates cell is empty on the table for some players.  I want to update the code (I believe just the swaprequestsent_view function in views.py) to eliminate the players without availabe dates from the table on swaprequestsent.html.  I want all other functionality to stay the same.
Highlight Key Parts: I want all functionality of the code to remain the same, I just want additional logic to eliminate users from the Available Players table who cannot offer future dates to swap for the offered date.
Examples: For swap offering player Chris Prouty, for tee time date 2024-07-27, John Kane and Pete Birmingham show up in the Available Players list but do not have available dates listed.  The code logic should check for this and not allow these players to be displayed in the table.

Ok.  More scariness.  I think it may be too easy to click buttons and have code change with the C.  This is surely my own paranoia but....  something happened there.

Anyway, 417 word prompt to get what I wanted but I think it worked.  Even though it was a small change.

That said, I think I did some fairly verbose prompting for the G AND it mostly had a blank slate to write on.  Either way.  I am freaked out and going to stop for a bit.  Maybe the night (538p btw).

The list as it stands:

Back to my list:
* order available dates by asc order
* eliminate players without available dates from swap list
* trial co-pilot [oh, we are trialing....]
* verify available dates are post offer date

Deeper list just to have it available
- add twilio to the sub and swap requests?
- automate some testing?  look at test frameworks
- get initial data page going with chart of player played with dates plus chart of which courses played and when (replicate google sheets in essence)
- figure out better error handling / error.html
- add a login page

20241203 249p
Ha.  Just sat down to do this....  but gonna hit walgreens real quick and pick up a sub.  Be back.

ok.  321p.  I am back.  And I already used C to knock something off the list:  verify available dates are post offer date

'The gDate__gt=gDate condition in the filter method ensures that only dates greater than (gt) the given swap date (gDate) are selected.'

So that is what the 'gt' meant.  I was wondering.

Ok.  Kinda leaning toward pulling in twilio functionality before wandering off and doing data then an initial game.  But...  yesterday's experience where I think C changed my code (and I had to use DropBox to undelete a file and restore it) has me somewhat concerned.

Maybe I should check in my code into GitHub?
